//
//  CBLReplicatorConfiguration.m
//  CouchbaseLite
//
//  Created by Pasin Suriyentrakorn on 5/25/17.
//  Copyright Â© 2017 Couchbase. All rights reserved.
//

#import "CBLReplicatorConfiguration.h"
#import "CBLAuthenticator+Internal.h"
#import "CBLReplicator+Internal.h"
#import "CBLDatabase+Internal.h"

#if TARGET_OS_IPHONE
#import <UIKit/UIKit.h>
#endif

#import "repo_version.h"    // Generated by get_repo_version.sh at build time

@implementation CBLReplicatorConfiguration

@synthesize database=_database, target=_target;
@synthesize replicatorType=_replicatorType, continuous=_continuous;
@synthesize conflictResolver=_conflictResolver;
@synthesize authenticator=_authenticator;
@synthesize pinnedServerCertificate=_pinnedServerCertificate;
@synthesize headers=_headers;
@synthesize documentIDs=_documentIDs, channels=_channels;
@synthesize checkpointInterval=_checkpointInterval;


+ (instancetype) withDatabase: (CBLDatabase*)database targetURL: (NSURL*)targetURL {
    return [[self alloc] initWithDatabase: database targetURL: targetURL];
}


+ (instancetype) withDatabase: (CBLDatabase*)database targetDatabase: (CBLDatabase*)targetDatabase {
    return [[self alloc] initWithDatabase: database targetDatabase: targetDatabase];
}


- (instancetype) initWithDatabase:(CBLDatabase *)database targetURL: (NSURL*)targetURL {
    self = [super init];
    if (self) {
        _replicatorType = kCBLPushAndPull;
        _database = database;
        _target = targetURL;
    }
    return self;
}


- (instancetype) initWithDatabase:(CBLDatabase *)database targetDatabase: (CBLDatabase*)targetDatabase {
    self = [super init];
    if (self) {
        _replicatorType = kCBLPushAndPull;
        _database = database;
        _target = targetDatabase;
    }
    return self;
}


- (instancetype) copyWithZone:(NSZone *)zone {
    CBLReplicatorConfiguration* c = [_target isKindOfClass: [NSURL class]] ?
        [[self.class alloc] initWithDatabase: _database targetURL: _target] :
        [[self.class alloc] initWithDatabase: _database targetDatabase: _target];
    c.replicatorType = _replicatorType;
    c.conflictResolver = _conflictResolver;
    c.continuous = _continuous;
    c.authenticator = _authenticator;
    c.pinnedServerCertificate = _pinnedServerCertificate;
    c.headers = _headers;
    c.documentIDs = _documentIDs;
    c.channels = _channels;
    c.checkpointInterval = _checkpointInterval;
    return c;
}

- (id<CBLConflictResolver>) conflictResolver {
    if (!_conflictResolver)
        _conflictResolver = [[CBLDefaultConflictResolver alloc] init];
    return _conflictResolver;
}


- (NSDictionary*) effectiveOptions {
    NSMutableDictionary* options = [NSMutableDictionary dictionary];
    
    NSURL* targetURL = $castIf(NSURL, _target);
    
    // If the URL has a hardcoded username/password, add them as an "auth" option:
    NSString* username = targetURL.user;
    if (username) {
        NSMutableDictionary *auth = [NSMutableDictionary new];
        auth[@kC4ReplicatorAuthUserName] = username;
        auth[@kC4ReplicatorAuthPassword] = targetURL.password;
        options[@kC4ReplicatorOptionAuthentication] = auth;
    } else
        [_authenticator authenticate: options];
    
    // Add the pinned certificate if any:
    if (_pinnedServerCertificate) {
        NSData* certData = CFBridgingRelease(SecCertificateCopyData(_pinnedServerCertificate));
        options[@kC4ReplicatorOptionPinnedServerCert] = certData;
    }
    
    // User-Agent and HTTP headers:
    NSMutableDictionary* httpHeaders = [NSMutableDictionary dictionary];
    httpHeaders[@"User-Agent"] = [self.class userAgentHeader];
    if (self.headers)
        [httpHeaders addEntriesFromDictionary: self.headers];
    options[@kC4ReplicatorOptionExtraHeaders] = httpHeaders;

    // Filters:
    options[@kC4ReplicatorOptionDocIDs] = _documentIDs;
    options[@kC4ReplicatorOptionChannels] = _channels;

    // Checkpoint Interval (no public api now):
    if (_checkpointInterval > 0)
        options[@kC4ReplicatorCheckpointInterval] = @(_checkpointInterval);
    
    return options;
}


+ (NSString*) userAgentHeader {
    static NSString* sUserAgent;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
#if TARGET_OS_IPHONE
        UIDevice* device = [UIDevice currentDevice];
        NSString* system = [NSString stringWithFormat: @"%@ %@; %@",
                            device.systemName, device.systemVersion, device.model];
#else
        NSOperatingSystemVersion v = [[NSProcessInfo processInfo] operatingSystemVersion];
        NSString* version = [NSString stringWithFormat:@"%ld.%ld.%ld",
                                   v.majorVersion, v.minorVersion, v.patchVersion];
        NSString* system = [NSString stringWithFormat: @"macOS %@", version];
#endif
        NSString* platform = strcmp(CBL_PRODUCT_NAME, "CouchbaseLiteSwift") == 0 ?
            @"Swift" : @"ObjC";
        
        NSString* commit = strlen(GitCommit) > (0) ?
            [NSString stringWithFormat: @"Commit/%.8s%s", GitCommit, GitDirty] : @"NA";
        
        sUserAgent = [NSString stringWithFormat: @"CouchbaseLite/%s (%@; %@) Build/%d %@",
                      CBL_VERSION_STRING, platform, system, CBL_BUILD_NUMBER, commit];
    });
    return sUserAgent;
}

@end
